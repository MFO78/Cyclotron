<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CYCLOTRON: Orbital Stack</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&display=swap');

        :root {
            --bg-color: #050508;
            --core-off: #1a1a20;
            --neon-cyan: #00f3ff;
            --neon-red: #ff0055;
            --neon-amber: #ffcc00;
            --neon-green: #00ff9d;
        }

        body {
            background-color: var(--bg-color);
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
            touch-action: none;
            user-select: none;
        }

        canvas { display: block; }

        .btn-control {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(4px);
            border-radius: 50%;
            transition: all 0.1s;
            pointer-events: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--neon-cyan);
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .btn-control:active {
            background: rgba(0, 243, 255, 0.2);
            box-shadow: 0 0 15px var(--neon-cyan);
            transform: scale(0.95);
        }

        .radar-sweep {
            position: absolute;
            top: 50%; left: 50%;
            width: 150vmax; height: 150vmax;
            transform: translate(-50%, -50%);
            background: conic-gradient(from 0deg, transparent 0deg, transparent 270deg, rgba(0, 243, 255, 0.05) 360deg);
            border-radius: 50%;
            animation: spin 6s linear infinite;
            pointer-events: none;
            z-index: 0;
        }
        
        @keyframes spin { 100% { transform: translate(-50%, -50%) rotate(360deg); } }

        .btn-rotate {
            border-color: rgba(255, 0, 85, 0.3);
            color: var(--neon-red);
        }

        /* Difficulty Buttons */
        .diff-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 8px;
            font-weight: bold;
            letter-spacing: 0.1em;
            border: 1px solid rgba(255,255,255,0.2);
            backdrop-filter: blur(5px);
            transition: all 0.2s;
            text-transform: uppercase;
        }
        .diff-btn:hover { transform: scale(1.02); }
        
        .btn-easy { color: var(--neon-green); border-color: var(--neon-green); background: rgba(0, 255, 157, 0.1); }
        .btn-easy:hover { background: rgba(0, 255, 157, 0.3); box-shadow: 0 0 15px var(--neon-green); }

        .btn-norm { color: var(--neon-amber); border-color: var(--neon-amber); background: rgba(255, 204, 0, 0.1); }
        .btn-norm:hover { background: rgba(255, 204, 0, 0.3); box-shadow: 0 0 15px var(--neon-amber); }

        .btn-hard { color: var(--neon-red); border-color: var(--neon-red); background: rgba(255, 0, 85, 0.1); }
        .btn-hard:hover { background: rgba(255, 0, 85, 0.3); box-shadow: 0 0 15px var(--neon-red); }

    </style>
</head>
<body class="h-screen w-screen flex flex-col items-center justify-center relative">

    <div class="radar-sweep"></div>

    <!-- HUD -->
    <div class="absolute top-4 left-4 z-20 pointer-events-none">
        <div class="text-xs text-gray-400 tracking-widest">ENERGY</div>
        <div id="score" class="text-2xl font-bold text-cyan-400">0</div>
        <div class="text-xs text-gray-400 tracking-widest mt-2">LEVEL</div>
        <div id="level" class="text-xl font-bold text-white">1</div>
    </div>
    
    <div class="absolute top-4 right-4 z-20 flex gap-4 pointer-events-auto">
        <button id="mute-btn" class="text-gray-400 hover:text-white transition-colors"><i class="fa-solid fa-volume-high text-xl"></i></button>
        <button id="restart-icon-btn" class="text-gray-400 hover:text-white transition-colors"><i class="fa-solid fa-power-off text-xl"></i></button>
    </div>

    <!-- Game Container -->
    <div class="relative z-10">
        <canvas id="game-canvas"></canvas>
        <div id="center-status" class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-center pointer-events-none transition-opacity duration-200" style="opacity: 0;">
            <div class="text-xs text-red-500 font-bold tracking-widest animate-pulse">CRITICAL FUSION</div>
        </div>
    </div>

    <!-- Overlay -->
    <div id="overlay" class="absolute inset-0 z-50 bg-black/90 flex flex-col items-center justify-center backdrop-blur-sm">
        <h1 class="text-5xl md:text-6xl font-bold mb-2 tracking-tighter text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-600">CYCLOTRON</h1>
        <div class="w-64 h-px bg-gray-800 mb-6"></div>
        
        <div id="menu-content" class="flex flex-col items-center w-64">
            <p class="text-xs text-gray-400 mb-4 tracking-widest">SELECT REACTOR GRADE</p>
            <button onclick="startGame(1000)" class="diff-btn btn-easy rounded">Stable (Easy)</button>
            <button onclick="startGame(700)" class="diff-btn btn-norm rounded">Unstable (Normal)</button>
            <button onclick="startGame(400)" class="diff-btn btn-hard rounded">Critical (Hard)</button>
        </div>

        <div id="game-over-content" class="hidden flex-col items-center w-64">
             <h2 class="text-3xl text-red-500 font-bold mb-2">MELTDOWN</h2>
             <p class="text-gray-400 mb-6">SYSTEM FAILURE</p>
             <button id="reset-btn" class="diff-btn btn-norm rounded">RE-INITIALIZE</button>
        </div>
    </div>

    <!-- Controls -->
    <div class="absolute bottom-6 w-full max-w-lg flex justify-between px-8 z-20 pointer-events-none">
        <div class="flex gap-4">
            <button id="btn-left" class="btn-control w-16 h-16 pointer-events-auto"><i class="fa-solid fa-rotate-left text-xl"></i></button>
            <button id="btn-right" class="btn-control w-16 h-16 pointer-events-auto"><i class="fa-solid fa-rotate-right text-xl"></i></button>
        </div>
        <div class="flex gap-4">
            <button id="btn-rotate" class="btn-control btn-rotate w-16 h-16 pointer-events-auto"><i class="fa-solid fa-arrows-rotate text-xl"></i></button>
            <button id="btn-drop" class="btn-control w-16 h-16 border-amber-500/50 text-amber-400 pointer-events-auto"><i class="fa-solid fa-angles-down text-xl"></i></button>
        </div>
    </div>

<script>
    /**
     * CYCLOTRON ENGINE v3.0
     * - Inverted Controls (User Preference)
     * - Difficulty Selection
     */

    const AudioSys = {
        ctx: null,
        enabled: true,
        init() {
            if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            if (this.ctx.state === 'suspended') this.ctx.resume();
        },
        toggle() {
            this.enabled = !this.enabled;
            const icon = this.enabled ? '<i class="fa-solid fa-volume-high text-xl"></i>' : '<i class="fa-solid fa-volume-xmark text-xl"></i>';
            document.getElementById('mute-btn').innerHTML = icon;
        },
        play(freq, type, dur, vol = 0.1) {
            if (!this.enabled || !this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + dur);
        },
        tick() { this.play(800, 'triangle', 0.05, 0.03); },
        rotate() { this.play(1200, 'sine', 0.1, 0.05); },
        lock() { this.play(150, 'sawtooth', 0.15, 0.1); },
        clear() { 
            this.play(800, 'sine', 0.2, 0.1); 
            setTimeout(() => this.play(1200, 'sine', 0.3, 0.1), 100);
        },
        gameOver() { this.play(100, 'sawtooth', 1.0, 0.3); }
    };

    const SECTORS = 16;   
    const RINGS = 14;     
    const INNER_RADIUS = 40; 
    
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');
    
    let grid = []; 
    let piece = { pos: {r: 0, s: 0}, shape: [], color: 0, active: false };
    let score = 0;
    let level = 1;
    let linesCleared = 0;
    let gameOver = true; // Start in Menu state
    let dropTimer = 0;
    let dropInterval = 800;
    let baseSpeed = 800;
    let lastTime = 0;

    const COLORS = [null, '#FF0D72', '#0DC2FF', '#0DFF72', '#F538FF', '#FF8E0D', '#FFE138', '#3877FF'];

    let cx, cy, radiusStep;
    function resize() {
        const size = Math.min(window.innerWidth, window.innerHeight) * 0.95;
        canvas.width = size;
        canvas.height = size;
        cx = size / 2;
        cy = size / 2;
        radiusStep = (cx - INNER_RADIUS - 10) / RINGS;
    }
    window.addEventListener('resize', resize);
    resize();

    function initGrid() {
        grid = Array(RINGS).fill().map(() => Array(SECTORS).fill(0));
    }

    function createShape(type) {
        if (type === 'I') return [{r:0,s:-1}, {r:0,s:0}, {r:0,s:1}, {r:0,s:2}];
        if (type === 'O') return [{r:0,s:0}, {r:0,s:1}, {r:1,s:0}, {r:1,s:1}];
        if (type === 'T') return [{r:0,s:-1}, {r:0,s:0}, {r:0,s:1}, {r:1,s:0}];
        if (type === 'L') return [{r:0,s:-1}, {r:0,s:0}, {r:0,s:1}, {r:1,s:-1}];
        if (type === 'J') return [{r:0,s:-1}, {r:0,s:0}, {r:0,s:1}, {r:1,s:1}];
        if (type === 'S') return [{r:1,s:-1}, {r:1,s:0}, {r:0,s:0}, {r:0,s:1}];
        if (type === 'Z') return [{r:0,s:-1}, {r:0,s:0}, {r:1,s:0}, {r:1,s:1}];
        return [{r:0,s:0}];
    }

    function spawnPiece() {
        const types = 'ILJOTSZ';
        const type = types[Math.floor(Math.random() * types.length)];
        piece.shape = createShape(type);
        piece.color = Math.floor(Math.random() * 7) + 1;
        piece.pos.r = RINGS - 2; 
        piece.pos.s = Math.floor(SECTORS / 2);
        
        if (checkCollision(piece.pos.r, piece.pos.s, piece.shape)) {
            triggerGameOver();
        }
    }

    function checkCollision(r, s, shape) {
        for (let block of shape) {
            let tr = r + block.r;
            let ts = (s + block.s + SECTORS * 10) % SECTORS; 
            
            if (tr < 0) return true;
            if (tr >= RINGS) continue; 
            if (grid[tr] && grid[tr][ts] !== 0) return true;
        }
        return false;
    }

    function lockPiece() {
        AudioSys.lock();
        for (let block of piece.shape) {
            let tr = piece.pos.r + block.r;
            let ts = (piece.pos.s + block.s + SECTORS * 10) % SECTORS;
            if (tr >= 0 && tr < RINGS) {
                grid[tr][ts] = piece.color;
            }
        }
        checkRings();
        spawnPiece();
    }

    function checkRings() {
        let cleared = 0;
        for (let r = 0; r < RINGS; r++) {
            let full = true;
            for (let s = 0; s < SECTORS; s++) {
                if (grid[r][s] === 0) {
                    full = false;
                    break;
                }
            }
            if (full) {
                cleared++;
                for (let nr = r; nr < RINGS - 1; nr++) {
                    grid[nr] = [...grid[nr+1]];
                }
                grid[RINGS-1] = Array(SECTORS).fill(0);
                r--;
            }
        }
        
        if (cleared > 0) {
            score += Math.pow(cleared, 2) * 100;
            linesCleared += cleared;
            level = Math.floor(linesCleared / 10) + 1;
            document.getElementById('score').innerText = score;
            document.getElementById('level').innerText = level;
            AudioSys.clear();
            
            // Speed scaling based on baseSpeed
            dropInterval = Math.max(100, baseSpeed - (level * 50));
            
            const flare = document.getElementById('center-status');
            flare.innerText = "RING FUSION";
            flare.style.opacity = 1;
            setTimeout(() => flare.style.opacity = 0, 500);
        }
    }

    // --- Movement & Rotation ---

    function rotatePiece() {
        if (gameOver) return;
        const newShape = piece.shape.map(p => ({ r: p.s, s: -p.r }));
        
        const kicks = [[0, 0], [0, 1], [0, -1], [0, 2], [0, -2], [1, 0], [-1, 0]];

        for (let kick of kicks) {
            const testR = piece.pos.r + kick[0];
            const testS = piece.pos.s + kick[1];
            
            if (!checkCollision(testR, testS, newShape)) {
                piece.shape = newShape;
                piece.pos.r = testR;
                piece.pos.s = testS;
                AudioSys.rotate();
                return; 
            }
        }
    }

    function move(dir) {
        if (gameOver) return;
        const newS = piece.pos.s + dir;
        if (!checkCollision(piece.pos.r, newS, piece.shape)) {
            piece.pos.s = newS;
            AudioSys.tick();
        }
    }

    function drop() {
        if (gameOver) return;
        if (!checkCollision(piece.pos.r - 1, piece.pos.s, piece.shape)) {
            piece.pos.r--;
        } else {
            lockPiece();
        }
        dropTimer = 0;
    }
    
    function hardDrop() {
        if (gameOver) return;
        while (!checkCollision(piece.pos.r - 1, piece.pos.s, piece.shape)) {
            piece.pos.r--;
        }
        lockPiece();
    }

    // --- Drawing ---

    function draw() {
        ctx.fillStyle = '#050508';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Grid Lines
        ctx.strokeStyle = '#1a1a20';
        ctx.lineWidth = 1;
        for (let r = 0; r <= RINGS; r++) {
            ctx.beginPath();
            ctx.arc(cx, cy, INNER_RADIUS + r * radiusStep, 0, Math.PI * 2);
            ctx.stroke();
        }
        for (let s = 0; s < SECTORS; s++) {
            const angle = (s / SECTORS) * Math.PI * 2;
            const rStart = INNER_RADIUS;
            const rEnd = INNER_RADIUS + RINGS * radiusStep;
            ctx.beginPath();
            ctx.moveTo(cx + Math.cos(angle) * rStart, cy + Math.sin(angle) * rStart);
            ctx.lineTo(cx + Math.cos(angle) * rEnd, cy + Math.sin(angle) * rEnd);
            ctx.stroke();
        }

        // Static Blocks
        for (let r = 0; r < RINGS; r++) {
            for (let s = 0; s < SECTORS; s++) {
                if (grid[r][s] !== 0) drawBlock(r, s, COLORS[grid[r][s]]);
            }
        }

        // Active Piece
        if (!gameOver) {
            ctx.shadowBlur = 15;
            // Ghost
            let ghostR = piece.pos.r;
            while (!checkCollision(ghostR - 1, piece.pos.s, piece.shape)) ghostR--;
            
            ctx.globalAlpha = 0.15;
            for (let block of piece.shape) {
                let r = ghostR + block.r;
                let s = (piece.pos.s + block.s + SECTORS * 10) % SECTORS;
                if (r >= 0 && r < RINGS) drawBlock(r, s, '#ffffff');
            }
            
            ctx.globalAlpha = 1.0;
            for (let block of piece.shape) {
                let r = piece.pos.r + block.r;
                let s = (piece.pos.s + block.s + SECTORS * 10) % SECTORS;
                if (r >= 0 && r < RINGS) drawBlock(r, s, COLORS[piece.color], true);
            }
            ctx.shadowBlur = 0;
        }
    }

    function drawBlock(r, s, color, active = false) {
        const angleStart = (s / SECTORS) * Math.PI * 2 - (Math.PI/2); 
        const angleEnd = ((s + 1) / SECTORS) * Math.PI * 2 - (Math.PI/2);
        const rInner = INNER_RADIUS + r * radiusStep;
        const rOuter = INNER_RADIUS + (r + 1) * radiusStep;

        ctx.fillStyle = color;
        if (active) ctx.shadowColor = color;

        ctx.beginPath();
        ctx.arc(cx, cy, rOuter - 1, angleStart + 0.02, angleEnd - 0.02);
        ctx.arc(cx, cy, rInner + 1, angleEnd - 0.02, angleStart + 0.02, true);
        ctx.closePath();
        ctx.fill();
        
        if (active) {
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.beginPath();
            ctx.arc(cx, cy, rOuter - 4, angleStart + 0.05, angleEnd - 0.05);
            ctx.arc(cx, cy, rInner + 4, angleEnd - 0.05, angleStart + 0.05, true);
            ctx.fill();
        }
    }

    // --- Loop ---

    function update(time = 0) {
        if (!gameOver) {
            const dt = time - lastTime;
            lastTime = time;
            dropTimer += dt;
            if (dropTimer > dropInterval) drop();
        }
        draw();
        requestAnimationFrame(update);
    }

    // --- State Management ---

    window.startGame = function(speed) {
        baseSpeed = speed;
        initGrid();
        score = 0;
        level = 1;
        linesCleared = 0;
        gameOver = false;
        dropInterval = speed;
        
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('menu-content').style.display = 'none';
        document.getElementById('game-over-content').style.display = 'none';
        
        AudioSys.init();
        spawnPiece();
        lastTime = performance.now();
        update(lastTime);
    }

    function triggerGameOver() {
        gameOver = true;
        AudioSys.gameOver();
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('menu-content').style.display = 'none';
        document.getElementById('game-over-content').style.display = 'flex';
    }

    document.getElementById('reset-btn').addEventListener('click', () => {
        document.getElementById('game-over-content').style.display = 'none';
        document.getElementById('menu-content').style.display = 'flex';
    });

    document.getElementById('restart-icon-btn').addEventListener('click', () => {
        gameOver = true;
        document.getElementById('overlay').style.display = 'flex';
        document.getElementById('game-over-content').style.display = 'none';
        document.getElementById('menu-content').style.display = 'flex';
    });

    // --- Input Handling ---

    document.addEventListener('keydown', e => {
        // INVERTED LOGIC APPLIED HERE
        if (e.keyCode === 37) move(1); // Left Arrow now moves Clockwise (+)
        else if (e.keyCode === 39) move(-1); // Right Arrow now moves Counter-Clockwise (-)
        else if (e.keyCode === 38) rotatePiece(); 
        else if (e.keyCode === 40) drop();
        else if (e.keyCode === 32) hardDrop();
    });

    const addTouch = (id, fn) => {
        const el = document.getElementById(id);
        el.addEventListener('touchstart', (e) => { e.preventDefault(); fn(); });
        el.addEventListener('mousedown', (e) => { e.preventDefault(); fn(); });
    };

    // INVERTED BUTTONS
    addTouch('btn-left', () => move(1)); // Left Button -> Clockwise
    addTouch('btn-right', () => move(-1)); // Right Button -> Counter-Clockwise
    
    addTouch('btn-rotate', () => rotatePiece());
    addTouch('btn-drop', () => hardDrop());
    
    canvas.addEventListener('touchstart', (e) => { 
        e.preventDefault(); 
        if (e.touches[0].clientY < window.innerHeight - 150) rotatePiece();
    });

    document.getElementById('mute-btn').addEventListener('click', () => AudioSys.toggle());

    // Initial State: Render background only
    draw();

</script>
</body>
</html>


